<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sakura: Sakura Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cherry_tree.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sakura
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A library for loading and modifying Celeste maps.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_sakura.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sakura Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_sakura_1_1_binary_packer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura_1_1_binary_packer.html">BinaryPacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_decal.html">Decal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Celeste decal (either foreground or background).  <a href="class_sakura_1_1_decal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_effect.html">Effect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A styleground effect.  <a href="class_sakura_1_1_effect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> is an XML like element, designed to store XML data.  <a href="class_sakura_1_1_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_entity.html">Entity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for string entities and triggers.  <a href="class_sakura_1_1_entity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_filler.html">Filler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all information relating to a Celeste map.  <a href="class_sakura_1_1_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_obj_tiles.html">ObjTiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a collection of object tiles.  <a href="class_sakura_1_1_obj_tiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_parallax.html">Parallax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a parallax background.  <a href="class_sakura_1_1_parallax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_room.html">Room</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for a celeste room.  <a href="class_sakura_1_1_room.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_stylegrounds.html">Stylegrounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores stylegrounds.  <a href="class_sakura_1_1_stylegrounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_tiles.html">Tiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that holds a group of tiles (either fg or bg).  <a href="class_sakura_1_1_tiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_vector2.html">Vector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d vector for math. Defines a generic 2d vector class with two components. Contains some math functions for it to help.  <a href="class_sakura_1_1_vector2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89551dc3aa76c64c8d324466a675a58c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a89551dc3aa76c64c8d324466a675a58c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a89551dc3aa76c64c8d324466a675a58c">IsType</a> (const std::any &amp;in)</td></tr>
<tr class="separator:a89551dc3aa76c64c8d324466a675a58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31585baec2f817999aa7840e5b10edc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#aa31585baec2f817999aa7840e5b10edc">ToString</a> (const std::any &amp;in)</td></tr>
<tr class="separator:aa31585baec2f817999aa7840e5b10edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada98e0286cf2279ffbb6fc766987021"><td class="memItemLeft" align="right" valign="top">std::any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#aada98e0286cf2279ffbb6fc766987021">FromString</a> (const std::string &amp;in)</td></tr>
<tr class="separator:aada98e0286cf2279ffbb6fc766987021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0a03fe81bbad33e77a0b839adaaf0141">LoadListFromElement</a> (std::vector&lt; T &gt; &amp;list, <a class="el" href="class_sakura_1_1_element.html">Element</a> *in)</td></tr>
<tr class="separator:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a56d85ffffba26f48191aa4f9a80e5c94">LoadListFromElement</a> (std::vector&lt; T * &gt; &amp;list, <a class="el" href="class_sakura_1_1_element.html">Element</a> *in)</td></tr>
<tr class="separator:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a8d1c8a2155982ca77b876898502bd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a84a8d1c8a2155982ca77b876898502bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a84a8d1c8a2155982ca77b876898502bd">SaveListAsElement</a> (std::vector&lt; T &gt; &amp;list, const std::string &amp;elementName)</td></tr>
<tr class="separator:a84a8d1c8a2155982ca77b876898502bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f80b6c5c95f85f20737c8ffdf3d9aac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6f80b6c5c95f85f20737c8ffdf3d9aac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a6f80b6c5c95f85f20737c8ffdf3d9aac">SaveListAsElement</a> (std::vector&lt; T * &gt; &amp;list, const std::string &amp;elementName)</td></tr>
<tr class="separator:a6f80b6c5c95f85f20737c8ffdf3d9aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1119c0841032421b3ccab2b5d919f1a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a1119c0841032421b3ccab2b5d919f1a3">LoadBlacklistedElements</a> (std::map&lt; std::string, std::any &gt; &amp;out, const std::vector&lt; std::string &gt; &amp;blacklist, <a class="el" href="class_sakura_1_1_element.html">Element</a> *e)</td></tr>
<tr class="separator:a1119c0841032421b3ccab2b5d919f1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f276ec35b128b0b807a23a1a96fa234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a7f276ec35b128b0b807a23a1a96fa234">LoadEntityXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="separator:a7f276ec35b128b0b807a23a1a96fa234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd676dc3d546faff1f088941d254f20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#afcd676dc3d546faff1f088941d254f20">LoadEntityPack</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="separator:afcd676dc3d546faff1f088941d254f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70754f03b1cb66813a7b2ba9b5533b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ae70754f03b1cb66813a7b2ba9b5533b9">SaveEntityPack</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="separator:ae70754f03b1cb66813a7b2ba9b5533b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad3f1d3704c46caca6c0f76680585f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ad4ad3f1d3704c46caca6c0f76680585f">SaveEntityXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="separator:ad4ad3f1d3704c46caca6c0f76680585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ab4c7a5b818ae785fbd3778d9b03f00f3">Read</a> (std::istream &amp;in, T &amp;v)</td></tr>
<tr class="separator:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ae23593b8d137d6fc6dc08ea7198d5c21">Read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f063a60a930a0cb4bee22508a53df6e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f063a60a930a0cb4bee22508a53df6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a7f063a60a930a0cb4bee22508a53df6e">Write</a> (std::ostream &amp;out, T v)</td></tr>
<tr class="separator:a7f063a60a930a0cb4bee22508a53df6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ffef6c591ae58f90621eeafbfba78"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#af53ffef6c591ae58f90621eeafbfba78">ReadBytes</a> (std::istream &amp;in, size_t count)</td></tr>
<tr class="separator:af53ffef6c591ae58f90621eeafbfba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a089ff4ab005a566a519a9881bb3a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a9a089ff4ab005a566a519a9881bb3a83">FileExists</a> (const std::string &amp;file)</td></tr>
<tr class="separator:a9a089ff4ab005a566a519a9881bb3a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27923f0423fa7f303e7224c03436b65c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a27923f0423fa7f303e7224c03436b65c">ReadString</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a27923f0423fa7f303e7224c03436b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c249e35512a31d387536fe3441e398e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3c249e35512a31d387536fe3441e398e">WriteString</a> (std::ostream &amp;out, const std::string &amp;v)</td></tr>
<tr class="separator:a3c249e35512a31d387536fe3441e398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aedf7780d538ee43b6d051d90f7683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#af1aedf7780d538ee43b6d051d90f7683">CreatePath</a> (const std::string &amp;path)</td></tr>
<tr class="separator:af1aedf7780d538ee43b6d051d90f7683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1452ae840c005a6c46e793c9c9cc60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3b1452ae840c005a6c46e793c9c9cc60">SplitStringToIntArray</a> (const std::string &amp;subject, char lineDelimiter, char elementDelimiter)</td></tr>
<tr class="separator:a3b1452ae840c005a6c46e793c9c9cc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfee63a99d1518f6a5108c0a0b93382f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#acfee63a99d1518f6a5108c0a0b93382f">SplitStringToCharArray</a> (const std::string &amp;subject, char delimiter)</td></tr>
<tr class="separator:acfee63a99d1518f6a5108c0a0b93382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0276c38d0dcd94446239571d23b3547"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ac0276c38d0dcd94446239571d23b3547">SplitString</a> (const std::string &amp;subject, char delimiter)</td></tr>
<tr class="separator:ac0276c38d0dcd94446239571d23b3547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9136c5cfb80d4b320136a22f9a2607ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a9136c5cfb80d4b320136a22f9a2607ac">StringReplace</a> (std::string &amp;subject, const std::string &amp;search, const std::string &amp;replace)</td></tr>
<tr class="separator:a9136c5cfb80d4b320136a22f9a2607ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9e4b0fae91a4d4356b62792953d0da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0d9e4b0fae91a4d4356b62792953d0da">LoadEffectsXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_effect.html">Effect</a> &gt; &amp;out)</td></tr>
<tr class="separator:a0d9e4b0fae91a4d4356b62792953d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a979ac783d7090fc4852c7276a7fd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3a979ac783d7090fc4852c7276a7fd1b">SaveXML</a> (const std::string &amp;filename, <a class="el" href="class_sakura_1_1_element.html">Element</a> *e)</td></tr>
<tr class="separator:a3a979ac783d7090fc4852c7276a7fd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b6f68d157c5daed751496a0c1bbf7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ad2b6f68d157c5daed751496a0c1bbf7c">LoadXML</a> (const std::string &amp;filename, const std::string &amp;baseElement=&quot;Map&quot;)</td></tr>
<tr class="separator:ad2b6f68d157c5daed751496a0c1bbf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0287fe94719f16ad7a8ad935b184a3fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0287fe94719f16ad7a8ad935b184a3fe">LoadXML</a> (tinyxml2::XMLElement *element)</td></tr>
<tr class="separator:a0287fe94719f16ad7a8ad935b184a3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4925c2f55ce33f2315c2399f77ce51e3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a4925c2f55ce33f2315c2399f77ce51e3">ScrubModuleName</a> (std::string &amp;elementName)</td></tr>
<tr class="separator:a4925c2f55ce33f2315c2399f77ce51e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0036f3c601c31360f09b23c4a6db1929"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0036f3c601c31360f09b23c4a6db1929">GetModuleName</a> (const std::string &amp;elementName)</td></tr>
<tr class="separator:a0036f3c601c31360f09b23c4a6db1929"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aedffe6df0e3db0c3aae48a4f853173be"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#aedffe6df0e3db0c3aae48a4f853173be">blacklistedEntityAttributes</a></td></tr>
<tr class="memdesc:aedffe6df0e3db0c3aae48a4f853173be"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains attributes <a class="el" href="class_sakura_1_1_entity.html" title="A class for string entities and triggers.">Entity</a> isn't supposed to store in defs.  <a href="namespace_sakura.html#aedffe6df0e3db0c3aae48a4f853173be">More...</a><br /></td></tr>
<tr class="separator:aedffe6df0e3db0c3aae48a4f853173be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940657d51b986395a53c5fd37f58210b"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::any &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a940657d51b986395a53c5fd37f58210b">defaultMapData</a></td></tr>
<tr class="memdesc:a940657d51b986395a53c5fd37f58210b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default room defs dictionary.  <a href="namespace_sakura.html#a940657d51b986395a53c5fd37f58210b">More...</a><br /></td></tr>
<tr class="separator:a940657d51b986395a53c5fd37f58210b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="af1aedf7780d538ee43b6d051d90f7683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aedf7780d538ee43b6d051d90f7683">&#9670;&nbsp;</a></span>CreatePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::CreatePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to create. A platform agnostic way of creating paths. Creates all sub directories needed to make it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a089ff4ab005a566a519a9881bb3a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a089ff4ab005a566a519a9881bb3a83">&#9670;&nbsp;</a></span>FileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::FileExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file exists, false if it doesn't. A platform agnostic way of checking if a file exists or not. </dd></dl>

</div>
</div>
<a id="aada98e0286cf2279ffbb6fc766987021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada98e0286cf2279ffbb6fc766987021">&#9670;&nbsp;</a></span>FromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::any Sakura::FromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An any equivalent to the string. Converts a string into an std::any equivalent </dd></dl>

</div>
</div>
<a id="a0036f3c601c31360f09b23c4a6db1929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0036f3c601c31360f09b23c4a6db1929">&#9670;&nbsp;</a></span>GetModuleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::GetModuleName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>The name of the element to search for a module. Gets the name of the module an element belongs to. Specifically returns everything up to the last instance of / </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89551dc3aa76c64c8d324466a675a58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89551dc3aa76c64c8d324466a675a58c">&#9670;&nbsp;</a></span>IsType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::IsType </td>
          <td>(</td>
          <td class="paramtype">const std::any &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Any to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the type of in and T are equal </dd></dl>

</div>
</div>
<a id="a1119c0841032421b3ccab2b5d919f1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1119c0841032421b3ccab2b5d919f1a3">&#9670;&nbsp;</a></span>LoadBlacklistedElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadBlacklistedElements </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::any &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>blacklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The map to save to. </td></tr>
    <tr><td class="paramname">blacklist</td><td>A list of keys to ignore when copying. </td></tr>
    <tr><td class="paramname">e</td><td>The element to load from. Copies attributes from the element to an output map. Ignores attributes with keys that are in the blacklist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9e4b0fae91a4d4356b62792953d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9e4b0fae91a4d4356b62792953d0da">&#9670;&nbsp;</a></span>LoadEffectsXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEffectsXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_effect.html">Effect</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to load from. </td></tr>
    <tr><td class="paramname">out</td><td>The dictionary to save to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. Loads a list of effect definitions from an XML file. </dd></dl>

</div>
</div>
<a id="afcd676dc3d546faff1f088941d254f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd676dc3d546faff1f088941d254f20">&#9670;&nbsp;</a></span>LoadEntityPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEntityPack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to read from. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save the types to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. Loads a list of entity types from a binary pack (the same as the celeste format) and puts them in a dictionary. Should be used for defining entity types (especially default editor ones) </dd></dl>

</div>
</div>
<a id="a7f276ec35b128b0b807a23a1a96fa234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f276ec35b128b0b807a23a1a96fa234">&#9670;&nbsp;</a></span>LoadEntityXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEntityXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to read from. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save the types to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure Loads a list of entity types from an XML file and puts them in a dictionary. Should be used for defining entity types (especially default editor ones). </dd></dl>

</div>
</div>
<a id="a56d85ffffba26f48191aa4f9a80e5c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d85ffffba26f48191aa4f9a80e5c94">&#9670;&nbsp;</a></span>LoadListFromElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadListFromElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to load to. </td></tr>
    <tr><td class="paramname">in</td><td>The element to load from. Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*. Allocates a new instance of T (using new) for each child element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a03fe81bbad33e77a0b839adaaf0141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a03fe81bbad33e77a0b839adaaf0141">&#9670;&nbsp;</a></span>LoadListFromElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadListFromElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to load to. </td></tr>
    <tr><td class="paramname">in</td><td>The element to load from. Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b6f68d157c5daed751496a0c1bbf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b6f68d157c5daed751496a0c1bbf7c">&#9670;&nbsp;</a></span>LoadXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a>* Sakura::LoadXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseElement</em> = <code>&quot;Map&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename to load from. </td></tr>
    <tr><td class="paramname">baseElement</td><td>the element to attempt to load from as the base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element loaded, null on failure. Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from an XML file. </dd></dl>

</div>
</div>
<a id="a0287fe94719f16ad7a8ad935b184a3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0287fe94719f16ad7a8ad935b184a3fe">&#9670;&nbsp;</a></span>LoadXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a>* Sakura::LoadXML </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element loaded,null on failure. Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from a tinyxml2 element. </dd></dl>

</div>
</div>
<a id="ae23593b8d137d6fc6dc08ea7198d5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23593b8d137d6fc6dc08ea7198d5c21">&#9670;&nbsp;</a></span>Read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Sakura::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. Loads a value from a stream and returns it. </dd></dl>

</div>
</div>
<a id="ab4c7a5b818ae785fbd3778d9b03f00f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c7a5b818ae785fbd3778d9b03f00f3">&#9670;&nbsp;</a></span>Read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to load into. Loads a value from a binary stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af53ffef6c591ae58f90621eeafbfba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53ffef6c591ae58f90621eeafbfba78">&#9670;&nbsp;</a></span>ReadBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; Sakura::ReadBytes </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to read from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The read bytes. Reads count bytes from the stream and returns it as a vector of characters. </dd></dl>

</div>
</div>
<a id="a27923f0423fa7f303e7224c03436b65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27923f0423fa7f303e7224c03436b65c">&#9670;&nbsp;</a></span>ReadString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ReadString </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The read string. Reads a string encoded in the C# format from the stream. Specifically this is: Size: 7 bits used to encode bits, 8th bit used to indicate whether more bits avaliable After size comes the data. </dd></dl>

</div>
</div>
<a id="ae70754f03b1cb66813a7b2ba9b5533b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70754f03b1cb66813a7b2ba9b5533b9">&#9670;&nbsp;</a></span>SaveEntityPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveEntityPack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to write to </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. Saves a list of entity types to a binary pack (the same as the celeste format) for later use in an editor. Should be used for saving entity types (especially editor ones) </dd></dl>

</div>
</div>
<a id="ad4ad3f1d3704c46caca6c0f76680585f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ad3f1d3704c46caca6c0f76680585f">&#9670;&nbsp;</a></span>SaveEntityXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveEntityXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to write to. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. Saves a list of entity types to an XML file for later use in an editor. Should be used for saving entity types (especially editor ones) </dd></dl>

</div>
</div>
<a id="a6f80b6c5c95f85f20737c8ffdf3d9aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f80b6c5c95f85f20737c8ffdf3d9aac">&#9670;&nbsp;</a></span>SaveListAsElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a>* Sakura::SaveListAsElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to load from. </td></tr>
    <tr><td class="paramname">elementName</td><td>The name of the element to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed element. Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list. </dd></dl>

</div>
</div>
<a id="a84a8d1c8a2155982ca77b876898502bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a8d1c8a2155982ca77b876898502bd">&#9670;&nbsp;</a></span>SaveListAsElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a>* Sakura::SaveListAsElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to load from. </td></tr>
    <tr><td class="paramname">elementName</td><td>The name of the element to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed element. Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list. </dd></dl>

</div>
</div>
<a id="a3a979ac783d7090fc4852c7276a7fd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a979ac783d7090fc4852c7276a7fd1b">&#9670;&nbsp;</a></span>SaveXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file stream to save to. </td></tr>
    <tr><td class="paramname">e</td><td>The element to save </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. Saves an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> to an XML file. </dd></dl>

</div>
</div>
<a id="a4925c2f55ce33f2315c2399f77ce51e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4925c2f55ce33f2315c2399f77ce51e3">&#9670;&nbsp;</a></span>ScrubModuleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ScrubModuleName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>The name of the element to clip Cuts out the module name and returns it. This specifically cuts out anything with / Specifically for cutting out mod module names and putting them in an attribute instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0276c38d0dcd94446239571d23b3547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0276c38d0dcd94446239571d23b3547">&#9670;&nbsp;</a></span>SplitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Sakura::SplitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The separating character for tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split up strings. Separates a string into multiple strings, broken apart by the delimiter character. </dd></dl>

</div>
</div>
<a id="acfee63a99d1518f6a5108c0a0b93382f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee63a99d1518f6a5108c0a0b93382f">&#9670;&nbsp;</a></span>SplitStringToCharArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;char&gt; &gt; Sakura::SplitStringToCharArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to tokenize </td></tr>
    <tr><td class="paramname">delimiter</td><td>The separating character for tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split up strings. Separates a string into multiple character arrays (strings), broken apart by the delimiter character. </dd></dl>

</div>
</div>
<a id="a3b1452ae840c005a6c46e793c9c9cc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1452ae840c005a6c46e793c9c9cc60">&#9670;&nbsp;</a></span>SplitStringToIntArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;int&gt; &gt; Sakura::SplitStringToIntArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>lineDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>elementDelimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to spit. </td></tr>
    <tr><td class="paramname">lineDelimiter</td><td>delimiter what character counts as "end of line" or new row </td></tr>
    <tr><td class="paramname">elementDelimiter</td><td>what character separates elements or new column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tokenized version of the string. Separates a string into a 2D array. line delimiter represents a new row (creates a new vector on the output) char delimiter represents a new column (creates a new integer on the latest vector) </dd></dl>

</div>
</div>
<a id="a9136c5cfb80d4b320136a22f9a2607ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9136c5cfb80d4b320136a22f9a2607ac">&#9670;&nbsp;</a></span>StringReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::StringReplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to replace in. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">replace</td><td>The string to replace search with. Replaces all instances of search with replace in the string subject. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa31585baec2f817999aa7840e5b10edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31585baec2f817999aa7840e5b10edc">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ToString </td>
          <td>(</td>
          <td class="paramtype">const std::any &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The std::any to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent of in. Converts an std::any into a string equivalent. </dd></dl>

</div>
</div>
<a id="a7f063a60a930a0cb4bee22508a53df6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f063a60a930a0cb4bee22508a53df6e">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::Write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The stream to save to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to save. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to save. Saves a value to a stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c249e35512a31d387536fe3441e398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c249e35512a31d387536fe3441e398e">&#9670;&nbsp;</a></span>WriteString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::WriteString </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The stream to save to. </td></tr>
    <tr><td class="paramname">v</td><td>The string to save. Saves a string to a file stream in the C# encoded format (check ReadString for details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aedffe6df0e3db0c3aae48a4f853173be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedffe6df0e3db0c3aae48a4f853173be">&#9670;&nbsp;</a></span>blacklistedEntityAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt; Sakura::blacklistedEntityAttributes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>contains attributes <a class="el" href="class_sakura_1_1_entity.html" title="A class for string entities and triggers.">Entity</a> isn't supposed to store in defs. </p>

</div>
</div>
<a id="a940657d51b986395a53c5fd37f58210b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940657d51b986395a53c5fd37f58210b">&#9670;&nbsp;</a></span>defaultMapData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string,std::any&gt; Sakura::defaultMapData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default room defs dictionary. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_sakura.html">Sakura</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
