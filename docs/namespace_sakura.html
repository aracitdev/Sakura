<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sakura: Sakura Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cherry_tree.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Sakura<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A library for loading and modifying Celeste maps.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespace_sakura.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Sakura Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_sakura_1_1_binary_packer"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura_1_1_binary_packer.html">BinaryPacker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_decal.html">Decal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Celeste decal (either foreground or background).  <a href="class_sakura_1_1_decal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_effect.html">Effect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A styleground effect.  <a href="class_sakura_1_1_effect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_element.html">Element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> is an XML like element, designed to store XML data.  <a href="class_sakura_1_1_element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_entity.html">Entity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for string entities and triggers.  <a href="class_sakura_1_1_entity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_filler.html">Filler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all information relating to a Celeste map.  <a href="class_sakura_1_1_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_obj_tiles.html">ObjTiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a collection of object tiles.  <a href="class_sakura_1_1_obj_tiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_parallax.html">Parallax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a parallax background.  <a href="class_sakura_1_1_parallax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_room.html">Room</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for a celeste room.  <a href="class_sakura_1_1_room.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_stylegrounds.html">Stylegrounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores stylegrounds.  <a href="class_sakura_1_1_stylegrounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_tiles.html">Tiles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that holds a group of tiles (either fg or bg).  <a href="class_sakura_1_1_tiles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sakura_1_1_vector2.html">Vector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2d vector for math.  <a href="class_sakura_1_1_vector2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c268c726c8e6ee4b0808ac2b057803a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c268c726c8e6ee4b0808ac2b057803a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3c268c726c8e6ee4b0808ac2b057803a">IsType</a> (const std::variant&lt; int32_t, bool, float, std::string &gt; &amp;in)</td></tr>
<tr class="separator:a3c268c726c8e6ee4b0808ac2b057803a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece9897b8dc7e0410357f6c91281f462"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#aece9897b8dc7e0410357f6c91281f462">ToString</a> (const std::variant&lt; int32_t, bool, float, std::string &gt; &amp;in)</td></tr>
<tr class="memdesc:aece9897b8dc7e0410357f6c91281f462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a variant into a string equivalent.  <a href="namespace_sakura.html#aece9897b8dc7e0410357f6c91281f462">More...</a><br /></td></tr>
<tr class="separator:aece9897b8dc7e0410357f6c91281f462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a21b54b926a168623603b2422c7635"><td class="memItemLeft" align="right" valign="top">std::variant&lt; int32_t, bool, float, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a19a21b54b926a168623603b2422c7635">FromString</a> (const std::string &amp;in)</td></tr>
<tr class="memdesc:a19a21b54b926a168623603b2422c7635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string into an std::any equivalent.  <a href="namespace_sakura.html#a19a21b54b926a168623603b2422c7635">More...</a><br /></td></tr>
<tr class="separator:a19a21b54b926a168623603b2422c7635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0a03fe81bbad33e77a0b839adaaf0141">LoadListFromElement</a> (std::vector&lt; T &gt; &amp;list, <a class="el" href="class_sakura_1_1_element.html">Element</a> *in)</td></tr>
<tr class="memdesc:a0a03fe81bbad33e77a0b839adaaf0141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*.  <a href="namespace_sakura.html#a0a03fe81bbad33e77a0b839adaaf0141">More...</a><br /></td></tr>
<tr class="separator:a0a03fe81bbad33e77a0b839adaaf0141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a56d85ffffba26f48191aa4f9a80e5c94">LoadListFromElement</a> (std::vector&lt; T * &gt; &amp;list, <a class="el" href="class_sakura_1_1_element.html">Element</a> *in)</td></tr>
<tr class="memdesc:a56d85ffffba26f48191aa4f9a80e5c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*. Allocates a new instance of T (using new) for each child element.  <a href="namespace_sakura.html#a56d85ffffba26f48191aa4f9a80e5c94">More...</a><br /></td></tr>
<tr class="separator:a56d85ffffba26f48191aa4f9a80e5c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d781aeff60304cd92c6a908c62da980"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d781aeff60304cd92c6a908c62da980"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a6d781aeff60304cd92c6a908c62da980">SaveListAsElement</a> (std::vector&lt; T &gt; &amp;list, const std::string &amp;elementName)</td></tr>
<tr class="memdesc:a6d781aeff60304cd92c6a908c62da980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list.  <a href="namespace_sakura.html#a6d781aeff60304cd92c6a908c62da980">More...</a><br /></td></tr>
<tr class="separator:a6d781aeff60304cd92c6a908c62da980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aca5f20bed3195fbbbba25591b9eae3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2aca5f20bed3195fbbbba25591b9eae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a2aca5f20bed3195fbbbba25591b9eae3">SaveListAsElement</a> (std::vector&lt; T * &gt; &amp;list, const std::string &amp;elementName)</td></tr>
<tr class="memdesc:a2aca5f20bed3195fbbbba25591b9eae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list.  <a href="namespace_sakura.html#a2aca5f20bed3195fbbbba25591b9eae3">More...</a><br /></td></tr>
<tr class="separator:a2aca5f20bed3195fbbbba25591b9eae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c54463ad98ba897b03efbe1e33a2b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a70c54463ad98ba897b03efbe1e33a2b8">LoadBlacklistedElements</a> (std::map&lt; std::string, std::variant&lt; int32_t, bool, float, std::string &gt; &gt; &amp;out, const std::vector&lt; std::string &gt; &amp;blacklist, <a class="el" href="class_sakura_1_1_element.html">Element</a> *e)</td></tr>
<tr class="memdesc:a70c54463ad98ba897b03efbe1e33a2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies attributes from the element to an output map. Ignores attributes with keys that are in the blacklist.  <a href="namespace_sakura.html#a70c54463ad98ba897b03efbe1e33a2b8">More...</a><br /></td></tr>
<tr class="separator:a70c54463ad98ba897b03efbe1e33a2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f276ec35b128b0b807a23a1a96fa234"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a7f276ec35b128b0b807a23a1a96fa234">LoadEntityXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="memdesc:a7f276ec35b128b0b807a23a1a96fa234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a list of entity types from an XML file and puts them in a dictionary. Should be used for defining entity types (especially default editor ones).  <a href="namespace_sakura.html#a7f276ec35b128b0b807a23a1a96fa234">More...</a><br /></td></tr>
<tr class="separator:a7f276ec35b128b0b807a23a1a96fa234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd676dc3d546faff1f088941d254f20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#afcd676dc3d546faff1f088941d254f20">LoadEntityPack</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="memdesc:afcd676dc3d546faff1f088941d254f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a list of entity types from a binary pack (the same as the celeste format) and puts them in a dictionary. Should be used for defining entity types (especially default editor ones)  <a href="namespace_sakura.html#afcd676dc3d546faff1f088941d254f20">More...</a><br /></td></tr>
<tr class="separator:afcd676dc3d546faff1f088941d254f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70754f03b1cb66813a7b2ba9b5533b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ae70754f03b1cb66813a7b2ba9b5533b9">SaveEntityPack</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="memdesc:ae70754f03b1cb66813a7b2ba9b5533b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a list of entity types to a binary pack (the same as the celeste format) for later use in an editor. Should be used for saving entity types (especially editor ones)  <a href="namespace_sakura.html#ae70754f03b1cb66813a7b2ba9b5533b9">More...</a><br /></td></tr>
<tr class="separator:ae70754f03b1cb66813a7b2ba9b5533b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad3f1d3704c46caca6c0f76680585f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ad4ad3f1d3704c46caca6c0f76680585f">SaveEntityXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;entities)</td></tr>
<tr class="memdesc:ad4ad3f1d3704c46caca6c0f76680585f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a list of entity types to an XML file for later use in an editor. Should be used for saving entity types (especially editor ones)  <a href="namespace_sakura.html#ad4ad3f1d3704c46caca6c0f76680585f">More...</a><br /></td></tr>
<tr class="separator:ad4ad3f1d3704c46caca6c0f76680585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ab4c7a5b818ae785fbd3778d9b03f00f3">Read</a> (std::istream &amp;in, T &amp;v)</td></tr>
<tr class="memdesc:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a binary stream.  <a href="namespace_sakura.html#ab4c7a5b818ae785fbd3778d9b03f00f3">More...</a><br /></td></tr>
<tr class="separator:ab4c7a5b818ae785fbd3778d9b03f00f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ae23593b8d137d6fc6dc08ea7198d5c21">Read</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a value from a stream and returns it.  <a href="namespace_sakura.html#ae23593b8d137d6fc6dc08ea7198d5c21">More...</a><br /></td></tr>
<tr class="separator:ae23593b8d137d6fc6dc08ea7198d5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f063a60a930a0cb4bee22508a53df6e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7f063a60a930a0cb4bee22508a53df6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a7f063a60a930a0cb4bee22508a53df6e">Write</a> (std::ostream &amp;out, T v)</td></tr>
<tr class="memdesc:a7f063a60a930a0cb4bee22508a53df6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a value to a stream.  <a href="namespace_sakura.html#a7f063a60a930a0cb4bee22508a53df6e">More...</a><br /></td></tr>
<tr class="separator:a7f063a60a930a0cb4bee22508a53df6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab229962ff5c89eac561414a93e02b511"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ab229962ff5c89eac561414a93e02b511">ReadBytes</a> (std::istream &amp;in, size_t count)</td></tr>
<tr class="memdesc:ab229962ff5c89eac561414a93e02b511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads count bytes from the stream and returns it as a vector of characters.  <a href="namespace_sakura.html#ab229962ff5c89eac561414a93e02b511">More...</a><br /></td></tr>
<tr class="separator:ab229962ff5c89eac561414a93e02b511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a089ff4ab005a566a519a9881bb3a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a9a089ff4ab005a566a519a9881bb3a83">FileExists</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a9a089ff4ab005a566a519a9881bb3a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">A platform agnostic way of checking if a file exists or not.  <a href="namespace_sakura.html#a9a089ff4ab005a566a519a9881bb3a83">More...</a><br /></td></tr>
<tr class="separator:a9a089ff4ab005a566a519a9881bb3a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27923f0423fa7f303e7224c03436b65c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a27923f0423fa7f303e7224c03436b65c">ReadString</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:a27923f0423fa7f303e7224c03436b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string encoded in the C# format from the stream. Specifically this is: Size: 7 bits used to encode bits, 8th bit used to indicate whether more bits avaliable After size comes the data.  <a href="namespace_sakura.html#a27923f0423fa7f303e7224c03436b65c">More...</a><br /></td></tr>
<tr class="separator:a27923f0423fa7f303e7224c03436b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c249e35512a31d387536fe3441e398e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3c249e35512a31d387536fe3441e398e">WriteString</a> (std::ostream &amp;out, const std::string &amp;v)</td></tr>
<tr class="memdesc:a3c249e35512a31d387536fe3441e398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a string to a file stream in the C# encoded format (check ReadString for details).  <a href="namespace_sakura.html#a3c249e35512a31d387536fe3441e398e">More...</a><br /></td></tr>
<tr class="separator:a3c249e35512a31d387536fe3441e398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aedf7780d538ee43b6d051d90f7683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#af1aedf7780d538ee43b6d051d90f7683">CreatePath</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:af1aedf7780d538ee43b6d051d90f7683"><td class="mdescLeft">&#160;</td><td class="mdescRight">A platform agnostic way of creating paths. Creates all sub directories needed to make it.  <a href="namespace_sakura.html#af1aedf7780d538ee43b6d051d90f7683">More...</a><br /></td></tr>
<tr class="separator:af1aedf7780d538ee43b6d051d90f7683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c15c6e42458f6d0fa88f82f13e33b1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a32c15c6e42458f6d0fa88f82f13e33b1">SplitStringToIntArray</a> (const std::string &amp;subject, char lineDelimiter, char elementDelimiter)</td></tr>
<tr class="memdesc:a32c15c6e42458f6d0fa88f82f13e33b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates a string into a 2D array. line delimiter represents a new row (creates a new vector on the output) char delimiter represents a new column (creates a new integer on the latest vector)  <a href="namespace_sakura.html#a32c15c6e42458f6d0fa88f82f13e33b1">More...</a><br /></td></tr>
<tr class="separator:a32c15c6e42458f6d0fa88f82f13e33b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2b4b721fc831d678e9ce6a1d32dcc1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a7c2b4b721fc831d678e9ce6a1d32dcc1">SplitStringToCharArray</a> (const std::string &amp;subject, char delimiter)</td></tr>
<tr class="memdesc:a7c2b4b721fc831d678e9ce6a1d32dcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates a string into multiple character arrays (strings), broken apart by the delimiter character.  <a href="namespace_sakura.html#a7c2b4b721fc831d678e9ce6a1d32dcc1">More...</a><br /></td></tr>
<tr class="separator:a7c2b4b721fc831d678e9ce6a1d32dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed8e17b5aeb1def1076cf0975056863"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a8ed8e17b5aeb1def1076cf0975056863">SplitString</a> (const std::string &amp;subject, char delimiter)</td></tr>
<tr class="memdesc:a8ed8e17b5aeb1def1076cf0975056863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates a string into multiple strings, broken apart by the delimiter character.  <a href="namespace_sakura.html#a8ed8e17b5aeb1def1076cf0975056863">More...</a><br /></td></tr>
<tr class="separator:a8ed8e17b5aeb1def1076cf0975056863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9136c5cfb80d4b320136a22f9a2607ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a9136c5cfb80d4b320136a22f9a2607ac">StringReplace</a> (std::string &amp;subject, const std::string &amp;search, const std::string &amp;replace)</td></tr>
<tr class="memdesc:a9136c5cfb80d4b320136a22f9a2607ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all instances of search with replace in the string subject.  <a href="namespace_sakura.html#a9136c5cfb80d4b320136a22f9a2607ac">More...</a><br /></td></tr>
<tr class="separator:a9136c5cfb80d4b320136a22f9a2607ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9e4b0fae91a4d4356b62792953d0da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0d9e4b0fae91a4d4356b62792953d0da">LoadEffectsXML</a> (const std::string &amp;filename, std::map&lt; std::string, <a class="el" href="class_sakura_1_1_effect.html">Effect</a> &gt; &amp;out)</td></tr>
<tr class="separator:a0d9e4b0fae91a4d4356b62792953d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a979ac783d7090fc4852c7276a7fd1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a3a979ac783d7090fc4852c7276a7fd1b">SaveXML</a> (const std::string &amp;filename, <a class="el" href="class_sakura_1_1_element.html">Element</a> *e)</td></tr>
<tr class="memdesc:a3a979ac783d7090fc4852c7276a7fd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> to an XML file.  <a href="namespace_sakura.html#a3a979ac783d7090fc4852c7276a7fd1b">More...</a><br /></td></tr>
<tr class="separator:a3a979ac783d7090fc4852c7276a7fd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbbb787f5600dae5c206b9da1b0e181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0bbbb787f5600dae5c206b9da1b0e181">LoadXML</a> (const std::string &amp;filename, const std::string &amp;baseElement=&quot;Map&quot;)</td></tr>
<tr class="memdesc:a0bbbb787f5600dae5c206b9da1b0e181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from an XML file.  <a href="namespace_sakura.html#a0bbbb787f5600dae5c206b9da1b0e181">More...</a><br /></td></tr>
<tr class="separator:a0bbbb787f5600dae5c206b9da1b0e181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93e260875813a0e8b495e29fd8f8aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ac93e260875813a0e8b495e29fd8f8aa7">LoadXML</a> (tinyxml2::XMLElement *element)</td></tr>
<tr class="memdesc:ac93e260875813a0e8b495e29fd8f8aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from a tinyxml2 element.  <a href="namespace_sakura.html#ac93e260875813a0e8b495e29fd8f8aa7">More...</a><br /></td></tr>
<tr class="separator:ac93e260875813a0e8b495e29fd8f8aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4925c2f55ce33f2315c2399f77ce51e3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a4925c2f55ce33f2315c2399f77ce51e3">ScrubModuleName</a> (std::string &amp;elementName)</td></tr>
<tr class="memdesc:a4925c2f55ce33f2315c2399f77ce51e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts out the module name and returns it. This specifically cuts out anything with / Specifically for cutting out mod module names and putting them in an attribute instead.  <a href="namespace_sakura.html#a4925c2f55ce33f2315c2399f77ce51e3">More...</a><br /></td></tr>
<tr class="separator:a4925c2f55ce33f2315c2399f77ce51e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0036f3c601c31360f09b23c4a6db1929"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a0036f3c601c31360f09b23c4a6db1929">GetModuleName</a> (const std::string &amp;elementName)</td></tr>
<tr class="memdesc:a0036f3c601c31360f09b23c4a6db1929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the name of the module an element belongs to. Specifically returns everything up to the last instance of /.  <a href="namespace_sakura.html#a0036f3c601c31360f09b23c4a6db1929">More...</a><br /></td></tr>
<tr class="separator:a0036f3c601c31360f09b23c4a6db1929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada38ca3eb103da3689718b8affd42d33"><td class="memItemLeft" align="right" valign="top">tinyxml2::XMLElement *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#ada38ca3eb103da3689718b8affd42d33">ConstructElement</a> (<a class="el" href="class_sakura_1_1_element.html">Element</a> *e, tinyxml2::XMLElement *parent, tinyxml2::XMLDocument &amp;doc)</td></tr>
<tr class="separator:ada38ca3eb103da3689718b8affd42d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a54b075b9cbadeec5442b543a507cea23"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a54b075b9cbadeec5442b543a507cea23">blacklistedEntityAttributes</a> ={&quot;x&quot;,&quot;y&quot;,&quot;id&quot;, &quot;originX&quot;,&quot;originX&quot;,&quot;width&quot;,&quot;height&quot;}</td></tr>
<tr class="memdesc:a54b075b9cbadeec5442b543a507cea23"><td class="mdescLeft">&#160;</td><td class="mdescRight">contains attributes <a class="el" href="class_sakura_1_1_entity.html" title="A class for string entities and triggers.">Entity</a> isn't supposed to store in defs.  <a href="namespace_sakura.html#a54b075b9cbadeec5442b543a507cea23">More...</a><br /></td></tr>
<tr class="separator:a54b075b9cbadeec5442b543a507cea23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316b9143b075004fb1ca09aa7110d32e"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, std::variant&lt; int32_t, bool, float, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a316b9143b075004fb1ca09aa7110d32e">defaultMapData</a></td></tr>
<tr class="memdesc:a316b9143b075004fb1ca09aa7110d32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default room defs dictionary.  <a href="namespace_sakura.html#a316b9143b075004fb1ca09aa7110d32e">More...</a><br /></td></tr>
<tr class="separator:a316b9143b075004fb1ca09aa7110d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94890bed83fe8083f08f3526d5bc2587"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_sakura.html#a94890bed83fe8083f08f3526d5bc2587">blacklistedRoomAttributes</a> = {&quot;width&quot;,&quot;height&quot;,&quot;x&quot;,&quot;y&quot;,&quot;name&quot;}</td></tr>
<tr class="separator:a94890bed83fe8083f08f3526d5bc2587"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada38ca3eb103da3689718b8affd42d33" name="ada38ca3eb103da3689718b8affd42d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada38ca3eb103da3689718b8affd42d33">&#9670;&nbsp;</a></span>ConstructElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tinyxml2::XMLElement * Sakura::ConstructElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tinyxml2::XMLDocument &amp;&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1aedf7780d538ee43b6d051d90f7683" name="af1aedf7780d538ee43b6d051d90f7683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aedf7780d538ee43b6d051d90f7683">&#9670;&nbsp;</a></span>CreatePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::CreatePath </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A platform agnostic way of creating paths. Creates all sub directories needed to make it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a089ff4ab005a566a519a9881bb3a83" name="a9a089ff4ab005a566a519a9881bb3a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a089ff4ab005a566a519a9881bb3a83">&#9670;&nbsp;</a></span>FileExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::FileExists </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A platform agnostic way of checking if a file exists or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the file exists, false if it doesn't. </dd></dl>

</div>
</div>
<a id="a19a21b54b926a168623603b2422c7635" name="a19a21b54b926a168623603b2422c7635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a21b54b926a168623603b2422c7635">&#9670;&nbsp;</a></span>FromString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::variant&lt; int32_t, bool, float, std::string &gt; Sakura::FromString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string into an std::any equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The string to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An string equivalent to in. </dd></dl>

</div>
</div>
<a id="a0036f3c601c31360f09b23c4a6db1929" name="a0036f3c601c31360f09b23c4a6db1929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0036f3c601c31360f09b23c4a6db1929">&#9670;&nbsp;</a></span>GetModuleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::GetModuleName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the name of the module an element belongs to. Specifically returns everything up to the last instance of /. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>The name of the element to search for a module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c268c726c8e6ee4b0808ac2b057803a" name="a3c268c726c8e6ee4b0808ac2b057803a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c268c726c8e6ee4b0808ac2b057803a">&#9670;&nbsp;</a></span>IsType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::IsType </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; int32_t, bool, float, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Variant to check against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if the type of in and T are equal </dd></dl>

</div>
</div>
<a id="a70c54463ad98ba897b03efbe1e33a2b8" name="a70c54463ad98ba897b03efbe1e33a2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c54463ad98ba897b03efbe1e33a2b8">&#9670;&nbsp;</a></span>LoadBlacklistedElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadBlacklistedElements </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::variant&lt; int32_t, bool, float, std::string &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>blacklist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies attributes from the element to an output map. Ignores attributes with keys that are in the blacklist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The map to save to. </td></tr>
    <tr><td class="paramname">blacklist</td><td>A list of keys to ignore when copying. </td></tr>
    <tr><td class="paramname">e</td><td>The element to load from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9e4b0fae91a4d4356b62792953d0da" name="a0d9e4b0fae91a4d4356b62792953d0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9e4b0fae91a4d4356b62792953d0da">&#9670;&nbsp;</a></span>LoadEffectsXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEffectsXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_effect.html">Effect</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to load from. </td></tr>
    <tr><td class="paramname">out</td><td>The dictionary to save to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. Loads a list of effect definitions from an XML file. </dd></dl>

</div>
</div>
<a id="afcd676dc3d546faff1f088941d254f20" name="afcd676dc3d546faff1f088941d254f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd676dc3d546faff1f088941d254f20">&#9670;&nbsp;</a></span>LoadEntityPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEntityPack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a list of entity types from a binary pack (the same as the celeste format) and puts them in a dictionary. Should be used for defining entity types (especially default editor ones) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to read from. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save the types to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a7f276ec35b128b0b807a23a1a96fa234" name="a7f276ec35b128b0b807a23a1a96fa234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f276ec35b128b0b807a23a1a96fa234">&#9670;&nbsp;</a></span>LoadEntityXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::LoadEntityXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a list of entity types from an XML file and puts them in a dictionary. Should be used for defining entity types (especially default editor ones). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to read from. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save the types to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure </dd></dl>

</div>
</div>
<a id="a56d85ffffba26f48191aa4f9a80e5c94" name="a56d85ffffba26f48191aa4f9a80e5c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d85ffffba26f48191aa4f9a80e5c94">&#9670;&nbsp;</a></span>LoadListFromElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadListFromElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*. Allocates a new instance of T (using new) for each child element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to load to. </td></tr>
    <tr><td class="paramname">in</td><td>The element to load from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a03fe81bbad33e77a0b839adaaf0141" name="a0a03fe81bbad33e77a0b839adaaf0141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a03fe81bbad33e77a0b839adaaf0141">&#9670;&nbsp;</a></span>LoadListFromElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::LoadListFromElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a list of classes from an element. Loops through the element's children. Each child is passed to the construtor of type T. T is expected to have a constructor which accepts an Element*. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list to load to. </td></tr>
    <tr><td class="paramname">in</td><td>The element to load from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbbb787f5600dae5c206b9da1b0e181" name="a0bbbb787f5600dae5c206b9da1b0e181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbbb787f5600dae5c206b9da1b0e181">&#9670;&nbsp;</a></span>LoadXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a> * Sakura::LoadXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>baseElement</em> = <code>&quot;Map&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from an XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename to load from. </td></tr>
    <tr><td class="paramname">baseElement</td><td>the element to attempt to load from as the base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element loaded, null on failure. </dd></dl>

</div>
</div>
<a id="ac93e260875813a0e8b495e29fd8f8aa7" name="ac93e260875813a0e8b495e29fd8f8aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93e260875813a0e8b495e29fd8f8aa7">&#9670;&nbsp;</a></span>LoadXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a> * Sakura::LoadXML </td>
          <td>(</td>
          <td class="paramtype">tinyxml2::XMLElement *&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> from a tinyxml2 element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The element loaded,null on failure. </dd></dl>

</div>
</div>
<a id="ae23593b8d137d6fc6dc08ea7198d5c21" name="ae23593b8d137d6fc6dc08ea7198d5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23593b8d137d6fc6dc08ea7198d5c21">&#9670;&nbsp;</a></span>Read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Sakura::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a stream and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The loaded value. </dd></dl>

</div>
</div>
<a id="ab4c7a5b818ae785fbd3778d9b03f00f3" name="ab4c7a5b818ae785fbd3778d9b03f00f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c7a5b818ae785fbd3778d9b03f00f3">&#9670;&nbsp;</a></span>Read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a value from a binary stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to load from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to load into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab229962ff5c89eac561414a93e02b511" name="ab229962ff5c89eac561414a93e02b511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab229962ff5c89eac561414a93e02b511">&#9670;&nbsp;</a></span>ReadBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; Sakura::ReadBytes </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads count bytes from the stream and returns it as a vector of characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to read from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The read bytes. </dd></dl>

</div>
</div>
<a id="a27923f0423fa7f303e7224c03436b65c" name="a27923f0423fa7f303e7224c03436b65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27923f0423fa7f303e7224c03436b65c">&#9670;&nbsp;</a></span>ReadString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ReadString </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string encoded in the C# format from the stream. Specifically this is: Size: 7 bits used to encode bits, 8th bit used to indicate whether more bits avaliable After size comes the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The stream to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The read string. </dd></dl>

</div>
</div>
<a id="ae70754f03b1cb66813a7b2ba9b5533b9" name="ae70754f03b1cb66813a7b2ba9b5533b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70754f03b1cb66813a7b2ba9b5533b9">&#9670;&nbsp;</a></span>SaveEntityPack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveEntityPack </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a list of entity types to a binary pack (the same as the celeste format) for later use in an editor. Should be used for saving entity types (especially editor ones) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to write to </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. </dd></dl>

</div>
</div>
<a id="ad4ad3f1d3704c46caca6c0f76680585f" name="ad4ad3f1d3704c46caca6c0f76680585f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ad3f1d3704c46caca6c0f76680585f">&#9670;&nbsp;</a></span>SaveEntityXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveEntityXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, <a class="el" href="class_sakura_1_1_entity.html">Entity</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a list of entity types to an XML file for later use in an editor. Should be used for saving entity types (especially editor ones) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file to write to. </td></tr>
    <tr><td class="paramname">entities</td><td>A map of entities to save. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a2aca5f20bed3195fbbbba25591b9eae3" name="a2aca5f20bed3195fbbbba25591b9eae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aca5f20bed3195fbbbba25591b9eae3">&#9670;&nbsp;</a></span>SaveListAsElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a> * Sakura::SaveListAsElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to load from. </td></tr>
    <tr><td class="paramname">elementName</td><td>The name of the element to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed element. </dd></dl>

</div>
</div>
<a id="a6d781aeff60304cd92c6a908c62da980" name="a6d781aeff60304cd92c6a908c62da980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d781aeff60304cd92c6a908c62da980">&#9670;&nbsp;</a></span>SaveListAsElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sakura_1_1_element.html">Element</a> * Sakura::SaveListAsElement </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an element from a list of T. T is expected to have a SaveToElement function. Creates an element with the provided name, then adds children from the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list to load from. </td></tr>
    <tr><td class="paramname">elementName</td><td>The name of the element to construct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed element. </dd></dl>

</div>
</div>
<a id="a3a979ac783d7090fc4852c7276a7fd1b" name="a3a979ac783d7090fc4852c7276a7fd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a979ac783d7090fc4852c7276a7fd1b">&#9670;&nbsp;</a></span>SaveXML()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Sakura::SaveXML </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sakura_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves an <a class="el" href="class_sakura_1_1_element.html" title="Element is an XML like element, designed to store XML data.">Element</a> to an XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file stream to save to. </td></tr>
    <tr><td class="paramname">e</td><td>The element to save </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a4925c2f55ce33f2315c2399f77ce51e3" name="a4925c2f55ce33f2315c2399f77ce51e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4925c2f55ce33f2315c2399f77ce51e3">&#9670;&nbsp;</a></span>ScrubModuleName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ScrubModuleName </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>elementName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts out the module name and returns it. This specifically cuts out anything with / Specifically for cutting out mod module names and putting them in an attribute instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementName</td><td>The name of the element to clip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ed8e17b5aeb1def1076cf0975056863" name="a8ed8e17b5aeb1def1076cf0975056863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed8e17b5aeb1def1076cf0975056863">&#9670;&nbsp;</a></span>SplitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Sakura::SplitString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates a string into multiple strings, broken apart by the delimiter character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to split. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The separating character for tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split up strings. </dd></dl>

</div>
</div>
<a id="a7c2b4b721fc831d678e9ce6a1d32dcc1" name="a7c2b4b721fc831d678e9ce6a1d32dcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2b4b721fc831d678e9ce6a1d32dcc1">&#9670;&nbsp;</a></span>SplitStringToCharArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; char &gt; &gt; Sakura::SplitStringToCharArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates a string into multiple character arrays (strings), broken apart by the delimiter character. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to tokenize </td></tr>
    <tr><td class="paramname">delimiter</td><td>The separating character for tokens. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split up strings. </dd></dl>

</div>
</div>
<a id="a32c15c6e42458f6d0fa88f82f13e33b1" name="a32c15c6e42458f6d0fa88f82f13e33b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c15c6e42458f6d0fa88f82f13e33b1">&#9670;&nbsp;</a></span>SplitStringToIntArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; int &gt; &gt; Sakura::SplitStringToIntArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>lineDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>elementDelimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates a string into a 2D array. line delimiter represents a new row (creates a new vector on the output) char delimiter represents a new column (creates a new integer on the latest vector) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to spit. </td></tr>
    <tr><td class="paramname">lineDelimiter</td><td>delimiter what character counts as "end of line" or new row </td></tr>
    <tr><td class="paramname">elementDelimiter</td><td>what character separates elements or new column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tokenized version of the string. </dd></dl>

</div>
</div>
<a id="a9136c5cfb80d4b320136a22f9a2607ac" name="a9136c5cfb80d4b320136a22f9a2607ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9136c5cfb80d4b320136a22f9a2607ac">&#9670;&nbsp;</a></span>StringReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::StringReplace </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all instances of search with replace in the string subject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subject</td><td>The string to replace in. </td></tr>
    <tr><td class="paramname">search</td><td>The string to search for. </td></tr>
    <tr><td class="paramname">replace</td><td>The string to replace search with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aece9897b8dc7e0410357f6c91281f462" name="aece9897b8dc7e0410357f6c91281f462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece9897b8dc7e0410357f6c91281f462">&#9670;&nbsp;</a></span>ToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Sakura::ToString </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; int32_t, bool, float, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a variant into a string equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The variant to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string equivalent of in. </dd></dl>

</div>
</div>
<a id="a7f063a60a930a0cb4bee22508a53df6e" name="a7f063a60a930a0cb4bee22508a53df6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f063a60a930a0cb4bee22508a53df6e">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::Write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a value to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The stream to save to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to save. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to save. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c249e35512a31d387536fe3441e398e" name="a3c249e35512a31d387536fe3441e398e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c249e35512a31d387536fe3441e398e">&#9670;&nbsp;</a></span>WriteString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Sakura::WriteString </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a string to a file stream in the C# encoded format (check ReadString for details). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The stream to save to. </td></tr>
    <tr><td class="paramname">v</td><td>The string to save. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a54b075b9cbadeec5442b543a507cea23" name="a54b075b9cbadeec5442b543a507cea23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b075b9cbadeec5442b543a507cea23">&#9670;&nbsp;</a></span>blacklistedEntityAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; Sakura::blacklistedEntityAttributes ={&quot;x&quot;,&quot;y&quot;,&quot;id&quot;, &quot;originX&quot;,&quot;originX&quot;,&quot;width&quot;,&quot;height&quot;}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>contains attributes <a class="el" href="class_sakura_1_1_entity.html" title="A class for string entities and triggers.">Entity</a> isn't supposed to store in defs. </p>

</div>
</div>
<a id="a94890bed83fe8083f08f3526d5bc2587" name="a94890bed83fe8083f08f3526d5bc2587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94890bed83fe8083f08f3526d5bc2587">&#9670;&nbsp;</a></span>blacklistedRoomAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; Sakura::blacklistedRoomAttributes = {&quot;width&quot;,&quot;height&quot;,&quot;x&quot;,&quot;y&quot;,&quot;name&quot;}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a316b9143b075004fb1ca09aa7110d32e" name="a316b9143b075004fb1ca09aa7110d32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316b9143b075004fb1ca09aa7110d32e">&#9670;&nbsp;</a></span>defaultMapData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; std::string, std::variant&lt; int32_t, bool, float, std::string &gt; &gt; Sakura::defaultMapData</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    </div>
<div class="line">    {<span class="stringliteral">&quot;c&quot;</span>, (int32_t)0},</div>
<div class="line">    {<span class="stringliteral">&quot;musicLayer1&quot;</span>, <span class="keyword">true</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;musicLayer2&quot;</span>, <span class="keyword">true</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;musicLayer3&quot;</span>, <span class="keyword">true</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;musicLayer4&quot;</span>, <span class="keyword">true</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;delayAltMusicFade&quot;</span>,<span class="keyword">false</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;dark&quot;</span>, <span class="keyword">false</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;space&quot;</span>, <span class="keyword">false</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;underwater&quot;</span>, <span class="keyword">false</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;whisper&quot;</span>, <span class="keyword">false</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;music&quot;</span>, <span class="stringliteral">&quot;music_oldsite_awake&quot;</span>},</div>
<div class="line">    {<span class="stringliteral">&quot;altMusic&quot;</span>, (std::string())},</div>
<div class="line">    {<span class="stringliteral">&quot;disableDownTransition&quot;</span>, (bool)(<span class="keyword">false</span>)},</div>
<div class="line">    {<span class="stringliteral">&quot;windPattern&quot;</span>,(std::string(<span class="stringliteral">&quot;None&quot;</span>))},</div>
<div class="line">    {<span class="stringliteral">&quot;cameraOffsetX&quot;</span>, (float)(0.0)},</div>
<div class="line">    {<span class="stringliteral">&quot;cameraOffsetY&quot;</span>, (float)(0.0)},</div>
<div class="line">    {<span class="stringliteral">&quot;musicProgress&quot;</span>,(std::string())},</div>
<div class="line">    {<span class="stringliteral">&quot;ambienceProgress&quot;</span>,(std::string())}</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>The default room defs dictionary. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_sakura.html">Sakura</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
